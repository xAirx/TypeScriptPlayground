

/* Generic Interfaces



/* Like classes, interfaces also can be generic. A generic interface has generic type parameter list in an angle brackets <> following the name of the interface:
 */
interface interfaceName<T> {
	// ...
}


/* This make the type parameter T visible to all members of the interface.

The type parameter list can have one or multiple types. For example:
 */


interface interfaceName<U, V> {
	// ...
}

/* TypeScript generic interface examples */
/*  */
/* Let’s take some examples of declaring generic interfaces. */

/////////////////////////////////
/////////////////////////////////
/* 1) Generic interfaces that describe object properties

The following show how to declare a generic interface that consists of two members key and value with the corresponding types K and V:
 */
interface Pair<K, V> {
	key: K;
	value: V;
}

/* Now, you can use the Pair interface for defining any key/value pair with any type. For example:
 */
let month: Pair<string, number> = {
	key: 'Jan',
	value: 1
};

console.log(month);

/* In this example, we declare a month key-value pair whose key is a string and value is a number.
 */

/////////////////////////////////
/////////////////////////////////
/* 2) Generic interfaces that describe methods

The following declares a generic interface with two methods add() and remove():
 */
interface Collection<T> {
	add(o: T): void;
	remove(o: T): void;
}
/*
And this List<T> generic class implements the Collection<T> generic interface:
 */
class List<T> implements Collection<T>{
	private items: T[] = [];

	add(o: T): void {
		this.items.push(o);
	}
	remove(o: T): void {
		let index = this.items.indexOf(o);
		if (index > -1) {
			this.items.splice(index, 1);
		}
	}
}



/* From the List<T> class, you can create a list of values of the various type e.g., numbers, or strings.

For example, the following shows how to use the List<T> generic class to create a list of numbers:
 */
let list = new List<number>();

for (let i = 0; i < 10; i++) {
	list.add(i);
}



/////////////////////////////////
/////////////////////////////////
/*  */
/* 3) Generic interfaces that describe index types */
/*  */
/* The following declare an interface that describes an index type: */

interface Options<T> {
	[name: string]: T
}

let inputOptions: Options<boolean> = {
	'disabled': false,
	'visible': true
};


/* This brings us on to generic interfaces; let’s create a generic

Identities interface to use with identities():  */

interface Identities<V, W> {
	id1: V,
	id2: W
}
/*
I have used V and W as our type variables here to demonstrate any letter(or combination of valid alphanumeric names) are valid types — there is no significance to what you call them, other then for conventional purposes.

We can now apply this interface as the return type of identities(), amending our return type to adhere to it.Let’s also console.log the arguments and their types for more clarification:
 */
function identities<T, U>(arg1: T, arg2: U): Identities<T, U> {


	console.log(arg1 + ": " + typeof (arg1));
	console.log(arg2 + ": " + typeof (arg2));

	let identities: Identities<T, U> = {
		id1: arg1,
		id2: arg2
	};
	return identities;
}
/* What we are doing to identities() now is passing types T and U into our function and Identities interface, allowing us to define the return types in relation to the argument types.
	Note: If you compile your Typescript project and look for your generics, you will not find any.As generics are not supported in Javascript, you will not see them in the build generated by your transpiler.Generics are purely a development safety net for compile time that will ensure type safe abstraction of your code.
 */
